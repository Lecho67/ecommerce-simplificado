version: '3.8' # Versión de Docker Compose

services:
  # Servicio de la base de datos PostgreSQL
  db:
    image: postgres:16-alpine # Una imagen ligera de PostgreSQL
    volumes:
      - postgres_data:/var/lib/postgresql/data/ # Monta un volumen para persistir los datos de la DB
    environment:
      POSTGRES_DB: postgres # Nombre de la base de datos
      POSTGRES_USER: postgres # Usuario de la base de datos
      POSTGRES_PASSWORD: mysecretpassword # ¡Cambia esto en producción!
    ports:
      - "5432:5432" # Expone el puerto 5432 del contenedor al host (opcional, solo si necesitas acceder a la DB directamente)
    healthcheck: # Healthcheck para asegurar que la DB esté lista antes de que el backend intente conectarse
      test: ["CMD-SHELL", "pg_isready -U postgres"] # Comando para verificar el estado de la DB
      interval: 5s
      timeout: 5s
      retries: 5 # Reintenta 5 veces antes de considerar que falló
      start_period: 30s # Espera 30 segundos antes de empezar a chequear (da tiempo a la DB para iniciar)

  # Servicio del Backend (Django REST Framework)
  backend:
    build: ./backend # Le dice a Docker Compose que construya la imagen desde el Dockerfile en './backend'
    # El comando que se ejecuta cuando el contenedor se inicia
    command: >
      sh -c "python manage.py makemigrations && # Genera migraciones (aunque ya las tenemos, buena práctica)
             python manage.py migrate &&       # Aplica migraciones a la DB
             python manage.py collectstatic --noinput && # Recopila archivos estáticos (para admin Django, si Nginx no lo hace)
             gunicorn ecommerce_backend.wsgi:application --bind 0.0.0.0:8000" # Inicia el servidor WSGI
    volumes:
      - ./backend:/app/backend # Monta el código fuente para desarrollo (hot-reloading si el server lo soporta)
      - staticfiles_volume:/app/backend/staticfiles # Monta un volumen para los archivos estáticos de Django
    ports:
      - "8000:8000" # Expone el puerto 8000 del contenedor al host
    environment:
      # Estas variables de entorno sobreescriben las de settings.py cuando se ejecuta en Docker
      # Asegúrate de que tu settings.py de Django usa estas variables o las de Docker.
      # En nuestro caso, Django busca los datos de la DB directamente en el DATABASES dict.
      # Para producción real, podrías usar una URL de DB en una variable de entorno.
      DJANGO_ALLOWED_HOSTS: "*" # Permite cualquier host en desarrollo. ¡CAMBIA ESTO EN PROD!
      DJANGO_SECRET_KEY: "your_django_secret_key" # ¡CAMBIA ESTO EN PROD POR UNA CLAVE SEGURA!
      # Database settings (deben coincidir con las de settings.py si no usas una DATABASE_URL)
      POSTGRES_NAME: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: mysecretpassword
      POSTGRES_HOST: db # El nombre del servicio de la DB en este mismo docker-compose.yml
      POSTGRES_PORT: 5432
    depends_on:
      db:
        condition: service_healthy # Asegura que la DB esté lista y saludable antes de iniciar el backend
    # Solo para desarrollo: Reinicia el contenedor si hay cambios en el código
    # restart: always # Descomentar para reiniciar automáticamente en desarrollo

  # Servicio del Frontend (React con Nginx)
  frontend:
    build:
      context: . # Construye la imagen desde el Dockerfile en './frontend'
      dockerfile: ./frontend/Dockerfile # Especifica el Dockerfile a usar
    volumes:
        - ./frontend:/app/frontend
        - /app/frontend/node_modules
        - staticfiles_volume:/usr/share/nginx/static # <--- ¡ESTA LÍNEA TAMBIÉN ES CRÍTICA!
    ports:
      - "3000:80" # Mapea el puerto 3000 del host al puerto 80 de Nginx en el contenedor
    environment:
      # Pasar variables de entorno de React
      # Si usas el proxy de Nginx, REACT_APP_API_URL debe ser /api/
      REACT_APP_API_URL: /api/ # Apunta al proxy de Nginx de Nginx (que redirige al backend)
    depends_on:
      backend:
        condition: service_started # Asegura que el backend esté corriendo antes de iniciar el frontend
    # restart: always # Descomentar para reiniciar automáticamente en desarrollo

# Define los volúmenes persistentes para los datos de la base de datos
volumes:
  postgres_data:
  staticfiles_volume: